## A*算法

### A*和NavMesh

#### A* 

1. 利用启发式函数，大大减少计算量
2. 易编辑，直接通过改变节点的表现形式，容易对地图进行动态的修改（例如生成建筑物）
3. 使用方块作为节点，如果地图很大，方块的数量就会导致处理时间的增加
4. 单位体积不一样的话，大单位可能会覆盖不可行走区域

#### NavMesh

1. 是对A*的一种扩展，基于场景不同区域，划分成众多不规则三角形
2. 通过计算导航网格上两点的位置关系，就可知道是否可行走或有无障碍物
3. 自带单位体积，在经过一些转角就可以加上体积半径进行计算
4. 也可以动态的改变地图区域，但是相对复杂



A*学习网站：http://theory.stanford.edu/~amitp/GameProgramming/

### 广度优先算法

从起点出发，每次可以朝上下左右四个方向进行移动，在一轮搜索完毕后，会标记这些探索过得方块为边界（绿色方块）， 然后循环往复的从这些边界方块开始，朝他们的上下左右四个方向继续探索 ，直到遍历到终点方块

![](https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/录制_2022_06_25_09_47_37_938.gif)

* 因为对路径的寻找是没有方向性的，会朝各个方向进行探索，所以在最坏的情况下，算法要跑完整张地图才能找到最短路径

### A*算法

A*算法也叫**启发式（Heuristic）**搜索，与广度优先不同的是，在每一轮循环的时候不会去搜索每个边界，而是选择当前“代价”最低的方块进行探索

#### 代价

* 当前路径代价（g）：代表从起点出发，一共走过多少个格子
* 预估代价（h）：代表当前方块到终点方块大概需要的距离
  * 欧拉距离（Euler Distance)：两点之间的直线距离
  * 曼哈顿距离（Manhattan Distance)：两点在竖直方向和水平方向上的距离总和
* 寻路消耗（f）：**f = g + h**

#### 基本原理

搜索过的方块个数明显比广度优先少很多

![](https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/微信截图_20220625100330.png)

#### 详细原理

![](https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/Snipaste_2022-06-25_11-14-37.png)

* 每到达一个新的节点，则计算其周围**还未在开启或关闭列表中**的并且不是阻挡的点，送进开启列表中，并记录父对象
* 然后排序开启列表，找出代价最少点，移入关闭列表（这步是算法最消耗性能的地方）
* 每次往关闭列表中放点时，都判断这个点是否是终点
* 找到终点后，**根据父对象回溯**
* 父对象存在意义：终点之前，因为程序并不知道阻挡的存在，所以总是会往一个**看似**正确的方向移动，最终遇到阻挡时，才会回退，直到正确路径，所以关闭列表中的节点最终并不是全部有用的



### 代码

油管大神：https://www.youtube.com/c/SebastianLague/videos

代码实现：https://github.com/x1aochen/AStart_Algorithm //详细注释

#### 使用堆结构做开启列表的优化

使用List存储开启列表，在每次寻找代价最低节点时，总是需要遍历全部元素，大大降低了性能，使用堆排序，维持一个顶部总是为最低代价的堆结构以提升性能

相同路径优化前：

```c#
Node currenNode = openSet[0]
//找到代价最低节点，总是需要遍历开启列表中的全部元素
for (int i = 1;i < openSet.Count; i++)
{
    //找到代价更小点，或者代价相等，但是h消耗更小点
    if (openSet[i].fCost < currenNode.fCost || openSet[i].fCost == currenNode.fCost && openSet[i].hCost < currenNode.hCost)
    {
       currenNode = openSet[i];
    }
}
```

![](https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/Snipaste_2022-06-25_22-59-09.png)

优化后：

![](https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/Snipaste_2022-06-25_23-04-59.png)

#### 多个单位行进与回溯路径简化

* 添加了任务请求类，使用协程处理多个单位需要同时进行寻路时的处理，在找到路径后通过回调函数中call到寻路后所需执行的事件，这边是往目标点移动

![](https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/录制_2022_06_26_12_13_51_359.gif)

* 原先存储在Grid类中的路径已经不需要了，转而在PathFinding中直接使用数组来存储回溯路径，并且简化了路径，使其只存储那些在方向上发生了改变的点，相比原本List中存放整条路径上的全部点，大大降低了内存消耗

  ![](https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/Snipaste_2022-06-26_11-54-19.png)



学习中。。。
